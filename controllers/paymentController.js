const User = require('../models/user');
const axios = require('axios');

// Payment amounts in tiyin (1 UZS = 100 tiyin)
const PAYMENT_AMOUNTS = {
  start: 260000, // 2600 UZS
  pro: 455000    // 4550 UZS
};

const applyPromoCode = async (req, res) => {
  try {
    const { userId, plan, promoCode } = req.body;

    // üîç Validate input presence
    if (!userId || !plan || !promoCode) {
      return res.status(400).json({ message: '‚ùå –í—Å–µ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã: userId, plan, promoCode' });
    }

    // üîê Validate promo code
    const validPromoCode = 'acedpromocode2406';
    if (promoCode.trim() !== validPromoCode) {
      return res.status(400).json({ message: '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø—Ä–æ–º–æ–∫–æ–¥' });
    }

    // üîç Validate plan type
    const allowedPlans = ['start', 'pro'];
    if (!allowedPlans.includes(plan)) {
      return res.status(400).json({ message: '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∞—Ä–∏—Ñ. –í–æ–∑–º–æ–∂–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: start, pro' });
    }

    // üßë Find user by ID
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ ID' });
    }

    // üíæ Update plan and status
    user.subscriptionPlan = plan;
    user.paymentStatus = 'paid';
    await user.save();

    return res.status(200).json({
      message: '‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–º–µ–Ω—ë–Ω',
      unlocked: true,
      plan
    });

  } catch (err) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–∞:', err);
    res.status(500).json({ message: '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –ø—Ä–æ–º–æ–∫–æ–¥–∞' });
  }
};

const initiatePaymePayment = async (req, res) => {
  try {
    const { userId, plan } = req.body;

    // üîç Validate input
    if (!userId || !plan) {
      return res.status(400).json({ 
        message: '‚ùå –í—Å–µ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã: userId, plan' 
      });
    }

    // üîç Validate plan type
    const allowedPlans = ['start', 'pro'];
    if (!allowedPlans.includes(plan)) {
      return res.status(400).json({ 
        message: '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∞—Ä–∏—Ñ. –í–æ–∑–º–æ–∂–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: start, pro' 
      });
    }

    // üßë Find user by ID
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ 
        message: '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ ID' 
      });
    }

    // Get payment amount for the plan
    const amount = PAYMENT_AMOUNTS[plan];
    if (!amount) {
      return res.status(400).json({ 
        message: '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∞—Ä–∏—Ñ –¥–ª—è –æ–ø–ª–∞—Ç—ã' 
      });
    }

    // Use user ID as login for Payme
    const accountLogin = userId;
    
    // Generate unique request ID
    const requestId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
    
    // Determine API endpoint based on environment
    const isProduction = process.env.NODE_ENV === 'production';
    const paymeApiUrl = isProduction 
      ? process.env.PAYME_API_URL_LIVE || 'https://checkout.paycom.uz/api'
      : process.env.PAYME_API_URL_SANDBOX || `${req.protocol}://${req.get('host')}/api/payments/sandbox`;

    console.log('üîç Payme payment initiation:', {
      userId,
      plan,
      amount,
      accountLogin,
      requestId,
      apiUrl: paymeApiUrl,
      isProduction
    });

    try {
      // Step 1: Check if transaction can be performed
      const checkResponse = await makePaymeRequest(paymeApiUrl, {
        id: requestId,
        method: 'CheckPerformTransaction',
        params: {
          account: { login: accountLogin },
          amount: amount
        }
      });

      console.log('‚úÖ CheckPerformTransaction response:', checkResponse);

      if (checkResponse.error) {
        console.error('‚ùå CheckPerformTransaction failed:', checkResponse.error);
        return res.status(400).json({
          message: '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ–ø–ª–∞—Ç—ã',
          error: checkResponse.error.message?.ru || checkResponse.error.message?.en || '–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏',
          code: checkResponse.error.code
        });
      }

      if (!checkResponse.result?.allow) {
        return res.status(400).json({
          message: '‚ùå –û–ø–ª–∞—Ç–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞'
        });
      }

      // Step 2: Create transaction
      const createResponse = await makePaymeRequest(paymeApiUrl, {
        id: requestId,
        method: 'CreateTransaction',
        params: {
          id: requestId,
          time: Date.now(),
          account: { login: accountLogin },
          amount: amount
        }
      });

      console.log('‚úÖ CreateTransaction response:', createResponse);

      if (createResponse.error) {
        console.error('‚ùå CreateTransaction failed:', createResponse.error);
        return res.status(400).json({
          message: '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é',
          error: createResponse.error.message?.ru || createResponse.error.message?.en || '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏',
          code: createResponse.error.code
        });
      }

      // Return success response with transaction details
      return res.status(200).json({
        message: '‚úÖ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞',
        success: true,
        transaction: {
          id: requestId,
          transaction: createResponse.result.transaction,
          amount: amount,
          plan: plan,
          state: createResponse.result.state,
          create_time: createResponse.result.create_time
        },
        // For frontend to continue with payment flow
        paymentUrl: isProduction 
          ? `https://checkout.paycom.uz/${process.env.PAYME_MERCHANT_ID}` 
          : null
      });

    } catch (apiError) {
      console.error('‚ùå Payme API error:', apiError);
      
      if (apiError.response) {
        console.error('API Response data:', apiError.response.data);
        console.error('API Response status:', apiError.response.status);
      }

      return res.status(500).json({
        message: '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ –ø–ª–∞—Ç—ë–∂–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ',
        error: apiError.message
      });
    }

  } catch (err) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞—Ü–∏–∏ –ø–ª–∞—Ç–µ–∂–∞:', err);
    res.status(500).json({ 
      message: '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞—Ü–∏–∏ –ø–ª–∞—Ç–µ–∂–∞',
      error: err.message 
    });
  }
};

// Helper function to make Payme API requests
const makePaymeRequest = async (url, payload) => {
  const merchantId = process.env.PAYME_MERCHANT_ID;
  const merchantKey = process.env.PAYME_MERCHANT_KEY;

  if (!merchantId || !merchantKey) {
    throw new Error('Payme credentials not configured');
  }

  // Prepare request
  const requestPayload = {
    jsonrpc: '2.0',
    ...payload
  };

  console.log('üîç Making Payme request:', {
    url,
    method: payload.method,
    hasAuth: !!(merchantId && merchantKey)
  });

  try {
    const response = await axios.post(url, requestPayload, {
      headers: {
        'Content-Type': 'application/json',
      },
      auth: {
        username: 'Paycom', // Always 'Paycom' for Payme
        password: merchantKey
      },
      timeout: 30000, // 30 second timeout
    });

    return response.data;
  } catch (error) {
    if (error.response) {
      // API responded with error status
      console.error('Payme API HTTP error:', {
        status: error.response.status,
        data: error.response.data
      });
      return error.response.data || { 
        error: { 
          code: -32000, 
          message: { en: 'API Error', ru: '–û—à–∏–±–∫–∞ API' } 
        } 
      };
    } else if (error.request) {
      // Network error
      console.error('Payme API network error:', error.message);
      throw new Error(`Network error: ${error.message}`);
    } else {
      // Other error
      console.error('Payme API request error:', error.message);
      throw error;
    }
  }
};

module.exports = { 
  applyPromoCode, 
  initiatePaymePayment 
};